# Delegatable Verification Protocol (DelVe)

**Version:** 0.1.0-draft  
**Date:** October 2025  
**Status:** Draft Specification

## Abstract

This document specifies the Delegatable Verification Protocol (DelVe), a system for verifying domain ownership across multiple decentralized services through an optional delegate service. DelVe enables domain owners to manage verification across numerous instances through a centralized interface while maintaining full control over authorization decisions, avoiding DNS record limitations, and optionally allowing manual verification for users who prefer direct control.

## Status of This Document

This is a draft specification. Implementations are encouraged, and feedback is welcome.

## Table of Contents

1. [Introduction](#1-introduction)
2. [Terminology](#2-terminology)
3. [Protocol Overview](#3-protocol-overview)
4. [Discovery Mechanism](#4-discovery-mechanism)
5. [Verification Flows](#5-verification-flows)
6. [API Specification](#6-api-specification)
7. [Cryptographic Requirements](#7-cryptographic-requirements)
8. [Security Considerations](#8-security-considerations)
9. [Privacy Considerations](#9-privacy-considerations)
10. [IANA Considerations](#10-iana-considerations)

---

## 1. Introduction

### 1.1 Problem Statement

Users who wish to establish domain-based identity across multiple decentralized services face several challenges:

- DNS providers often limit the number of TXT records per domain (typically 10-25)
- Managing verification records across many services requires frequent DNS modifications
- No centralized audit trail of which services have been verified
- Manual DNS updates are error-prone and lack user-friendly interfaces

### 1.2 Goals

- Enable domain owners to verify their identity across unlimited services
- Provide optional delegation to simplify management
- Maintain domain owner control through explicit authorization
- Support both delegated and non-delegated verification modes
- Be protocol-agnostic (works with ActivityPub, ATProto, or custom protocols)
- Ensure cryptographic integrity of verification

### 1.3 Non-Goals

- Replace existing DNS-based verification (DelVe is complementary)
- Provide identity management beyond verification
- Specify how services use verified identities

### 1.4 Use Cases

**Use Case 1: Multi-Instance Presence**  
Alice wants to use `alice@example.com` on multiple Fediverse instances, several Matrix servers, and various other decentralized platforms without hitting DNS limits.

**Use Case 2: Organization Management**  
A company wants to manage domain verification for 50+ employees across 20 different platforms with audit trails and revocation capabilities.

**Use Case 3: Privacy-Conscious User**  
Bob prefers to manually sign challenges without delegating to a third-party service, maintaining full control over his cryptographic keys.

---

## 2. Terminology

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.

**Domain Owner**: The entity that controls a domain and wishes to verify ownership across services.

**Verifier** (or **Instance**): A service that needs to verify a user's ownership of a domain.

**Delegate**: An optional service that holds cryptographic keys and signs challenges on behalf of the Domain Owner after authorization.

**Challenge**: A time-limited, unique value generated by a Verifier to prove domain ownership.

**Verification Token**: A signed challenge that proves domain ownership.

**Direct Verification**: Verification mode where the Domain Owner manually signs challenges without a Delegate.

**Delegated Verification**: Verification mode where authorization and signing is performed by a Delegate service.

---

## 3. Protocol Overview

### 3.1 Architecture

```
┌─────────────────┐
│  Domain Owner   │
│  example.com    │
└────────┬────────┘
         │
         │ (optional)
         ▼
┌─────────────────┐      ┌──────────────┐
│    Delegate     │◄────►│  Verifier    │
│    Service      │      │  (Instance)  │
└─────────────────┘      └──────────────┘
         │
         │ (or direct)
         ▼
┌─────────────────┐
│  Domain Owner   │
│  Manual Signing │
└─────────────────┘
```

### 3.2 High-Level Flow

1. **Discovery**: Verifier discovers how the domain performs verification (delegated or direct)
2. **Challenge**: Verifier generates a challenge for the domain
3. **Authorization** (delegated only): Domain Owner authorizes the Delegate to sign
4. **Signing**: Challenge is signed (by Delegate or Domain Owner)
5. **Verification**: Verifier validates the signature using the public key

### 3.3 Modes of Operation

#### 3.3.1 Delegated Mode

- Domain Owner sets up delegation via DNS
- Delegate generates and stores keypair
- Domain Owner authorizes signing through Delegate's interface
- Suitable for users managing many verifications

#### 3.3.2 Direct Mode

- Domain Owner publishes public key via DNS
- Domain Owner manually signs each challenge
- No third-party involved
- Suitable for privacy-conscious users or technical users

---

## 4. Discovery Mechanism

### 4.1 DNS-Based Discovery

A domain MUST publish verification configuration using a DNS TXT record at:

```
_delve.example.com
```

#### 4.1.1 Delegated Mode Configuration

```
_delve.example.com. IN TXT "v=delve0.1; mode=delegate; endpoint=https://delegate.service.com; key=<DELEGATE_PUBLIC_KEY>"
```

**Fields:**

- `v`: Protocol version (currently "delve0.1")
- `mode`: "delegate" for delegated mode
- `endpoint`: HTTPS URL of the delegate service
- `key`: Base64-encoded Ed25519 public key of the delegate

#### 4.1.2 Direct Mode Configuration

```
_delve.example.com. IN TXT "v=delve0.1; mode=direct; key=<OWNER_PUBLIC_KEY>"
```

**Fields:**

- `v`: Protocol version (currently "delve0.1")
- `mode`: "direct" for direct mode
- `key`: Base64-encoded Ed25519 public key of the domain owner

### 4.2 Well-Known Endpoint (Optional)

Domains MAY also publish configuration at:

```
https://example.com/.well-known/_delve.json
```

**Example:**

```json
{
  "version": "0.1",
  "mode": "delegate",
  "endpoint": "https://delegate.service.com",
  "publicKey": "<BASE64_PUBLIC_KEY>",
  "keyId": "example.com-2025-01",
  "updatedAt": "2025-10-02T10:30:00Z"
}
```

Verifiers SHOULD prefer DNS discovery over the well-known endpoint for security reasons.

---

## 5. Verification Flows

### 5.1 Delegated Verification Flow

```
Verifier          Delegate Service      Domain Owner
   │                     │                     │
   │  1. Discovery       │                     │
   ├────────────────────►│                     │
   │  (DNS lookup)       │                     │
   │                     │                     │
   │  2. Issue Challenge │                     │
   ├────────────────────►│                     │
   │  POST /challenge    │                     │
   │                     │                     │
   │                     │  3. Request Auth    │
   │                     ├────────────────────►│
   │                     │  (UI/notification)  │
   │                     │                     │
   │                     │  4. Authorize       │
   │                     │◄────────────────────┤
   │                     │                     │
   │  5. Retrieve Token  │                     │
   ├────────────────────►│                     │
   │  GET /token         │                     │
   │                     │                     │
   │  6. Verify Sig      │                     │
   │◄────────────────────┤                     │
   │                     │                     │
```

#### 5.1.1 Step-by-Step Process

1. **Discovery**: Verifier performs DNS lookup for `_delve.example.com` TXT record
2. **Challenge Issuance**: Verifier POSTs challenge to Delegate endpoint
3. **User Authorization**: Delegate notifies Domain Owner and requests authorization
4. **Authorization**: Domain Owner approves or rejects the request through Delegate UI
5. **Token Retrieval**: Verifier retrieves signed token from Delegate
6. **Verification**: Verifier validates signature using public key from DNS

### 5.2 Direct Verification Flow

```
Verifier              Domain Owner
   │                        │
   │  1. Discovery          │
   ├───────────────────────►│
   │  (DNS lookup)          │
   │                        │
   │  2. Generate Challenge │
   │  (display to user)     │
   ├───────────────────────►│
   │                        │
   │                        │  3. Manual Sign
   │                        │  (local tool)
   │                        │
   │  4. Submit Token       │
   │◄───────────────────────┤
   │                        │
   │  5. Verify Signature   │
   │                        │
```

#### 5.2.1 Step-by-Step Process

1. **Discovery**: Verifier performs DNS lookup for `_delve.example.com` TXT record
2. **Challenge Generation**: Verifier generates challenge and displays it to user
3. **Manual Signing**: Domain Owner uses local tooling to sign the challenge
4. **Token Submission**: Domain Owner submits signed token to Verifier
5. **Verification**: Verifier validates signature using public key from DNS

---

## 6. API Specification

### 6.1 Delegate Service Endpoints

All endpoints MUST use HTTPS. All requests and responses use `application/json` content type.

#### 6.1.1 POST /v1/challenge

**Request:**

```json
{
  "domain": "example.com",
  "verifierId": "service.example.net",
  "challenge": "random-base64-challenge-value",
  "expiresAt": "2025-10-02T12:00:00Z",
  "metadata": {
    "serviceName": "Example Social Network",
    "userIdentifier": "[email protected]"
  }
}
```

**Response (202 Accepted):**

```json
{
  "requestId": "req-uuid-here",
  "status": "pending",
  "authorizationUrl": "https://delegate.service.com/authorize/req-uuid-here",
  "expiresAt": "2025-10-02T12:00:00Z"
}
```

**Response (400 Bad Request):**

```json
{
  "error": "invalid_challenge",
  "message": "Challenge must be base64 encoded and at least 32 bytes"
}
```

#### 6.1.2 GET /v1/token/{requestId}

**Response (200 OK - authorized):**

```json
{
  "requestId": "req-uuid-here",
  "status": "authorized",
  "token": {
    "domain": "example.com",
    "verifierId": "service.example.net",
    "challenge": "original-challenge-value",
    "signature": "base64-encoded-signature",
    "publicKey": "base64-encoded-public-key",
    "keyId": "example.com-2025-01",
    "signedAt": "2025-10-02T11:30:00Z",
    "expiresAt": "2025-10-02T12:00:00Z"
  }
}
```

**Response (202 Accepted - pending):**

```json
{
  "requestId": "req-uuid-here",
  "status": "pending",
  "authorizationUrl": "https://delegate.service.com/authorize/req-uuid-here"
}
```

**Response (403 Forbidden - rejected):**

```json
{
  "requestId": "req-uuid-here",
  "status": "rejected",
  "rejectedAt": "2025-10-02T11:25:00Z"
}
```

#### 6.1.3 DELETE /v1/authorization/{verifierId}

Revoke authorization for a specific verifier.

**Response (200 OK):**

```json
{
  "domain": "example.com",
  "verifierId": "unique-service-id",
  "status": "revoked",
  "revokedAt": "2025-10-02T11:45:00Z"
}
```

### 6.2 Verifier Implementation

Verifiers MUST:

1. Generate cryptographically secure random challenges (minimum 32 bytes)
2. Set reasonable expiration times (recommended: 15-60 minutes)
3. Validate signatures before accepting verification
4. Cache DNS lookups appropriately (respect TTL)
5. Handle all HTTP error codes gracefully

---

## 7. Cryptographic Requirements

### 7.1 Key Algorithm

This specification uses **Ed25519** (EdDSA with Curve25519) for all signatures.

Implementations:

- MUST support Ed25519
- MAY support additional algorithms in future versions

### 7.2 Challenge Format

Challenges MUST be:

- At least 32 bytes of cryptographically secure random data
- Base64-encoded for transmission
- Include a timestamp component to prevent replay attacks

**Recommended format:**

```
base64(timestamp || random_bytes(32))
```

### 7.3 Signature Format

The signature covers a canonical JSON representation of:

```json
{
  "domain": "example.com",
  "verifierId": "service.example.net",
  "challenge": "base64-challenge",
  "signedAt": "2025-10-02T11:30:00Z"
}
```

The signature MUST be computed over the UTF-8 encoded, minified JSON (no whitespace) with keys in lexicographic order.

### 7.4 Signature Verification

Verifiers MUST:

1. Retrieve public key from DNS `_delve` record
2. Reconstruct the canonical signing payload
3. Verify the Ed25519 signature
4. Check that `signedAt` is within acceptable time window
5. Verify challenge matches the one originally issued
6. Confirm the domain and verifierId match expected values

---

## 8. Security Considerations

### 8.1 Threat Model

**Threats:**

- Delegate service compromise
- DNS spoofing/hijacking
- Man-in-the-middle attacks
- Challenge replay attacks
- Unauthorized signing requests

### 8.2 Mitigations

#### 8.2.1 Delegate Service Compromise

- Domain Owners retain control through explicit authorization
- Signing requires active user approval (not automatic)
- Revocation mechanism allows removing compromised authorizations
- Encourage self-hosting of delegate services

#### 8.2.2 DNS Security

- Verifiers SHOULD support DNSSEC validation
- Use HTTPS for all delegate endpoints
- Pin delegate public keys in DNS records

#### 8.2.3 Challenge Replay

- Challenges MUST include timestamps
- Challenges MUST expire (recommended: 15-60 minutes)
- Verifiers MUST track used challenges and reject duplicates
- Signed tokens MUST include `signedAt` timestamp

#### 8.2.4 Man-in-the-Middle

- All delegate communication MUST use HTTPS
- Verifiers MUST validate TLS certificates
- Consider certificate pinning for high-security deployments

### 8.3 Rate Limiting

Delegate services SHOULD implement rate limiting:

- Per domain: 100 challenge requests per hour
- Per IP: 1000 requests per hour
- Per verifier: 10 pending authorizations per domain

### 8.4 Authorization Security

Delegate services MUST:

- Implement secure user authentication
- Display verifier identity clearly during authorization
- Support multi-factor authentication (RECOMMENDED)
- Log all authorization decisions
- Provide audit trails to domain owners

---

## 9. Privacy Considerations

### 9.1 Information Disclosure

**What is revealed:**

- Domain ownership
- List of services where domain is verified (via delegate logs)
- Timing of verification attempts

**What is NOT revealed:**

- User activity on verified services
- Content of communications
- Relationship between different domains

### 9.2 Delegate Service Privacy

Delegate services:

- MUST NOT share authorization data with third parties
- SHOULD allow domain owners to delete historical data
- SHOULD support pseudonymous domain verification where possible
- MUST provide clear privacy policies

### 9.3 Verifier Privacy

Verifiers SHOULD:

- Not include unnecessary metadata in challenge requests
- Respect domain owner's choice of direct vs delegated verification
- Not track or correlate verification attempts across domains

---

## 10. IANA Considerations

### 10.1 DNS TXT Record Prefix

This specification registers the `_delve` DNS label prefix for domain verification records.

### 10.2 Well-Known URI

This specification registers the `/.well-known/_delve.json` URI for domain verification discovery.

---

## Appendix A: Examples

### A.1 Complete Delegated Verification Example

**1. DNS Configuration:**

```
_delve.example.com. 3600 IN TXT "v=delve0.1; mode=delegate; endpoint=https://verify.example.org; key=MCowBQYDK2VwAyEAXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
```

**2. Verifier Issues Challenge:**

```bash
curl -X POST https://verify.example.org/v1/challenge \
  -H "Content-Type: application/json" \
  -d '{
    "domain": "example.com",
    "verifierId": "social.example.net",
    "challenge": "MjAyNS0xMC0wMlQxMDowMDowMFp8cmFuZG9tZGF0YWhlcmU=",
    "expiresAt": "2025-10-02T11:00:00Z",
    "metadata": {
      "serviceName": "Example Social",
      "userIdentifier": "[email protected]"
    }
  }'
```

**3. Domain Owner Authorizes** (via web UI)

**4. Verifier Retrieves Token:**

```bash
curl https://verify.example.org/v1/token/req-uuid-here
```

**5. Verifier Validates Signature** using public key from DNS

### A.2 Direct Verification Example

**1. DNS Configuration:**

```
_delve.example.com. 3600 IN TXT "v=delve0.1; mode=direct; key=MCowBQYDK2VwAyEAYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY"
```

**2. Verifier Displays Challenge to User**

**3. User Signs Locally:**

```bash
echo '{"domain":"example.com","verifierId":"social.example.net","challenge":"MjAyNS0xMC0wMlQxMDowMDowMFp8cmFuZG9tZGF0YWhlcmU=","signedAt":"2025-10-02T10:30:00Z"}' | \
  delve-sign --key private-key.pem
```

**4. User Submits Signature to Verifier**

---

## Appendix B: Comparison with Other Systems

### B.1 vs. Traditional DNS TXT Verification

- **DelVe Pro**: Scales to unlimited verifications, centralized management
- **DNS Pro**: Simpler, no third party required
- **Use DelVe when**: Managing many verifications or hitting DNS limits

---

## Authors

The Mikoto Platforms Team
